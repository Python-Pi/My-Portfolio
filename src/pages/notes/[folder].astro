---
import BaseLayout from '../../layouts/BaseLayout.astro';
import SEO from '../../components/SEO.astro';
import PageStats from '../../components/PageStats.astro';
import ArticleCard from '../../components/ArticleCard.astro';
import { pagesConfig } from '../../pages.config';
import { notesIndex } from '../../content/notes/notes-index';
import type { NotesFolder, NotesEntry } from '../../content/notes/notes-index';
import { getEntry } from 'astro:content';

export const prerender = true;

type NotesEntryWithContent = NotesEntry & {
  resolvedTitle: string;
  resolvedDescription?: string;
  publishDate: Date;
  tags?: string[];
  status?: 'published' | 'ongoing' | 'archived';
};

type NotesFolderWithContent = NotesFolder & { entries: NotesEntryWithContent[] };

export async function getStaticPaths() {
  return Promise.all(
    notesIndex.map(async (folder) => ({
      params: { folder: folder.id },
      props: {
        folder: {
          ...folder,
          entries: (
            await Promise.all(
              folder.entries.map(async (entry) => {
                const contentEntry = await getEntry(entry.collection, entry.slug);
                const slugSegment = entry.slug.split('/').pop() ?? entry.slug;
                const fallbackTitle = slugSegment
                  .replace(/-/g, ' ')
                  .replace(/\b\w/g, (char) => char.toUpperCase());
                const resolvedTitle = contentEntry?.data.title ?? fallbackTitle;
                const publishDate = contentEntry?.data.publishDate as Date;
                const tags = (contentEntry?.data as { tags?: string[] }).tags;
                const status = (contentEntry?.data as { status?: 'published' | 'ongoing' | 'archived' }).status;

                return {
                  ...entry,
                  resolvedTitle,
                  resolvedDescription: contentEntry?.data.description ?? entry.summary ?? '',
                  publishDate,
                  tags,
                  status,
                } satisfies NotesEntryWithContent;
              })
            )
          ).sort((a, b) => b.publishDate.getTime() - a.publishDate.getTime()),
        } satisfies NotesFolderWithContent,
      },
    }))
  );
}

const { folder } = Astro.props as { folder: NotesFolderWithContent };
const config = pagesConfig.notes;
const pageTitle = `${folder.title} Â· ${config.title}`;
const pageDescription = folder.description ?? `All saved entries for ${folder.title}.`;
---

<BaseLayout>
  <SEO
    slot="head"
    title={pageTitle}
    description={pageDescription}
    type="website"
  />

  <main class="page-container">
    <header class="page-header">
      <p class="page-label">Notes folder</p>
      <h1 class="page-title">{folder.title}</h1>
      {folder.description && <p class="page-description">{folder.description}</p>}
      <PageStats
        text={
          folder.entries.length === 0
            ? '0 entries'
            : `${folder.entries.length} ${folder.entries.length === 1 ? 'entry' : 'entries'}`
        }
      />
    </header>

    {folder.entries.length > 0 ? (
      <div class="card-list card-list--compact">
        {folder.entries.map((entry) => {
          const enrichedEntry = entry as NotesEntryWithContent;
          const basePath = '/blogs';
          return (
            <ArticleCard
              title={enrichedEntry.resolvedTitle}
              slug={enrichedEntry.slug}
              description={enrichedEntry.resolvedDescription ?? ''}
              publishDate={enrichedEntry.publishDate}
              tags={enrichedEntry.tags}
              status={enrichedEntry.status}
              basePath={basePath}
            />
          );
        })}
      </div>
    ) : (
      <p class="empty-state">No entries in this folder yet.</p>
    )}
  </main>
</BaseLayout>
